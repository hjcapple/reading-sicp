## P271 - [练习 4.19]

我支持 Alyssa 的观点。

Ben 的观点从顺序执行的角度是最自然的，但没有考虑作用域。让外部的作用域影响了内层的作用域，或者让内层作用域覆盖外层作用域。可能会产生难以发现的问题。按照 Ben 的做法，下面的语句不能执行

``` Scheme
(define (f x)
  (define b (+ a x))
  (define a 5)
  (+ a b))
(f 10)
```

但外层定义了 a 之后，就可以执行成功。这时下面两个语句中 

``` Scheme
(define b (+ a x))
(+ a b)
```
处于相同的作用域，但看到的具体 a 变量是完全不同的。内层的 a 覆盖了外层的 a，他们处于相同的作用域，使用同一个符合，但是含义却不相同，这会无意中产生一些难以发现的问题。

Eva 的观点中。在相同作用域内，define 的顺序是任意的，define 语句可以不讲究顺序。但这种方法难以实现，需要自动分析 define 语句的相互依赖。另外我们看代码，习惯从上到下，顺序语句更容易理解。Eva 的观点中，后面的 define 语句会影响前面的语句结果，这不符合代码顺序执行，这种直观。人们更容易理解顺序，更难理解同时。

Alyssa 的观点，其实是正文的做法，同时考虑了作用域和顺序执行。它遵守下面规则。

1. 同一作用域下，相同符号的变量含义相同，访问同一个变量。
2. 在符合规则 1 的情况下，代码顺序执行。

这种规则相对容易理解，也容易实现。按照 Alyssa 的观点，习题中的代码会发生错误，强迫程序员编写更好的代码。

------

Eva 定义的方案，define 可以不讲究顺序，是完全同时的。要实现这种概念上的同时性（但解释器实际是顺序执行的），就需要调整 define 语句的顺序。将所有的 define 放到作用域的前面。另外需要分析 define 语句的依赖关系，构成一个依赖图，让依赖越小的越靠前。这个依赖分析有点麻烦，类似于预先运行解释器一次。
